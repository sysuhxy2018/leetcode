### 代码

``` java
import java.util.*;

// 3Sum
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if (n < 3)
            return ans;
        Arrays.sort(nums);
        for (int i = 0; i < n - 2; i++) {
            if (i - 1 >= 0 && nums[i] == nums[i - 1])
                continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0 || nums[i] + nums[n - 1] + nums[n - 2] < 0)
                continue;
            int j = i + 1, k = n - 1;
            while (j < k) {
                int tmp = nums[i] + nums[j] + nums[k];
                if (tmp < 0)
                    j++;
                else if (tmp > 0)
                    k--;
                else {
                    ans.add(new ArrayList<Integer>(Arrays.asList(nums[i], nums[j], nums[k])));
                    j++;
                    while (j < k && nums[j] == nums[j - 1])
                        j++;
                }
            }
        }
        return ans;     
    }
}

// 4Sum
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        if (n < 4)
            return ans;
        Arrays.sort(nums);
        for (int i = 0; i < n - 3; i++) {
            if (i - 1 >= 0 && nums[i] == nums[i - 1])
                continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target ||
               nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3] < target)
                continue;
            for (int j = i + 1; j < n - 2; j++) {
                // 注意这里j的起点从 i + 1 开始， 所以j - 1 >= i + 1，而不是 >= 0
                if (j - 1 >= i + 1 && nums[j] == nums[j - 1])
                    continue;
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target ||
                   nums[i] + nums[j] + nums[n - 1] + nums[n - 2] < target)
                    continue;
                int k = j + 1, l = n - 1;
                while (k < l) {
                    int tmp = nums[i] + nums[j] + nums[k] + nums[l];
                    if (tmp < target)
                        k++;
                    else if (tmp > target)
                        l--;
                    else{
                        ans.add(new ArrayList<>(Arrays.asList(
                            nums[i], nums[j], nums[k], nums[l])));
                        k++;
                        while (k < l && nums[k] == nums[k - 1])
                            k++;
                    }
                }
            }
        }
        return ans;
    }
}
```



### 思路

k sum问题。除了2 sum可以用哈希表将时间复杂度降为O(n)外，当k >= 3时，方法都是公式化的，时间复杂度为O(n ^ (k - 1))。

* 先将数组排序（默认升序）。

* 然后多个for循环嵌套，每次固定一个数的位置（剩下的数都在它后面）。直到剩下两个数为止，这两个数我们用while循环双指针去确定。如4 sum问题中：第一层for表示第一个数，它的区间范围是[0, n - 3)，因为至少要留3个数的位置给剩余的数；第二层for表示第二个数，它的区间范围是[i + 1, n - 2)，因为至少要留2个数的位置给剩余的数；然后第三，第四个数我们用while循环去遍历。

* for循环中的细节。

  * 重复处理。因为for里我们每次是固定一个数，所以如果是相同的数，可以直接跳过，否则会重复。注意这里我们不能在每次for循环一开始就直接跳到所有重复的数里面最后一个。这样做会导致一个问题：压缩了后面数选择的区间。比如3，3，3，3。如果我们直接跳到最后一个3，那么后面的数就不能再选3了。我们应该从第一个3开始，这样后面的数就能够有选择的空间。第一个新数结束后，就一个个跳过重复的数直到遇到一个新的不同的数。所以**for里逐个跳过重复数的模板**应该这样写：

    * ``` java
      for (int i = 0; i < n - 3; i++) {
          if (i - 1 >= 0 && nums[i] == nums[i - 1])
              continue;
          // 这里操作的数都是不重复的
      }
      ```

  * 预判处理。根据我们固定的数，我们可以预测出所得到的和的最大值和最小值。如果最大值比target还要小，说明固定的数 + 剩下的数所得到的所有结果都会 < target，即不需要考虑剩下的数，直接更新固定的数即可；如果最小值比target还要大，则同理，不需要后续的操作。这两个极值都是根据已经固定的数确定的，方法如下：

    * 最小值。比如4 sum里，我们固定了nums[i] 和 nums[j]。由于数组已经按照升序处理了，所以剩余的两个数的下标应该尽可能靠近 j。则最小值为nums[i] + nums[j] + nums[j + 1] + nums[j + 2]。这里我们给 j 后面预留了至少两个空位，所以 j + 1 和 j + 2下标有效。
    * 最大值。比如4 sum里，固定了nums[i] 和 nums[j]。则剩余两个数的下标应该尽可能大，则最大值为nums[i] + nums[j] + nums[n - 2] + nums[n - 1]。这里 j 的范围是  < n - 2的，即下标n - 2和n - 1是存在且有效的。

* while循环中的细节。

  * 重复处理。在不考虑重复情况下的while应该就只有3种情况：和 < target，low++；和 > target，high--；和 == target，low++，high--。这里的重复只发生在==情况，因为此时我们会将4个数添加到结果表里面。由于我们在前面已经固定了 k - 2个数，所以只需考虑这组数对是否重复。其实很简单，在两个数的和固定的情况下，只要一个数不同，则另一个数也会跟着变。换句话说，我们只要每次添加完一次结果后，跳过和nums[low]重复的数即可，即只需把low++修改成low位移到一个新数位置。**while一次性跳过所有重复的数的模板**，有2种写法。两种写法均可，看个人喜好。

    * ``` java
      // 先从重复里的第一个数跳到最后一个数，然后再移一位到新数。和后一位比较。
      while (j + 1 < k && nums[j] == nums[j + 1]) 
          j++;
      j++;
      ```

    * ``` java
      // 从重复里的第二个数开始，最后跳到新的不重复的数。和前一位比较。
      j++;
      while (j < k && nums[j] == nums[j - 1])
          j++;
      ```

  * 细节补充。还是关于重复处理，目前的写法是比较简单省事的。更严谨一点的写法应该是对于3种情况内的所有low++和high--，都进行重复处理。如low不是++，而是移到新数；high也不是--，而也是移到新数。但其实在这里完全没有影响，可以不去做额外的处理，否则代码会稍显臃肿。



### 总结

由于这里用到了数组转列表的方法，所以简单总结一下。（只是知道可以这么用= =)

核心是Arrays.asList()方法，从名字就可知该方法返回的是一个List，注意不是ArrayList或LinkedList等。这个方法对于对象数组很好用，但如果数组是基本数据类型就不能用它了。如果我们最终是要把数组转成ArrayList，则把得到的list作为ArrayList构造方法的参数即可。

对于基本数据类型我们可以这么写：

* new ArrayList\<Integer\>(Arrays.asList(new Integer[]{1, 2, 3}))。注意如果Integer写成int会报错。
* new ArrayList\<Integer\>(Arrays.asList(1, 2, 3))。看了下源码，asList好像支持可变长参数列表？所以这样写其实是转成了String类型的args数组？......

