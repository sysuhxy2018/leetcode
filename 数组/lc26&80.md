### 代码

``` java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int i = 0, j = 0;
        while (i < n) {
            int cnt = 0;
            while (i + 1 < n && nums[i + 1] == nums[i]) {
                if (cnt < 2) {
                    nums[j] = nums[i];
                    j++;
                    cnt++;
                }
                i++;
            }
            if (cnt < 2) {
                nums[j] = nums[i];
                j++;
                cnt++;
            }
            i++;  
        }
        return j;
    }
}
```



### 思路

这两题比较类似，就放到一起说了。先简单说一下我自己的写法。

* 维护两个指针，i 为遍历指针，j为覆盖指针（表示当前可被覆盖的下标位置）。都初始化为0。
* while i 不越界
  * 设置cnt = 0用于计数。
  * while 遍历一直到最后一个不重复的数
    * 其中如果cnt < 2，就更新nums[j]。然后cnt 和 j 都更新。
    * 遍历下标 i 更新。
  * 经过上面的while，i 已经到最后一个不重复的数了
    * 其中如果cnt < 2，就更新nums[j]。然后cnt 和 j 都更新。
    * 遍历下标 i 更新。
* 最后 j 就表示已经覆盖的元素数量，即新数组的长度，返回 j 即可。



### 总结

这个思路还算易懂，但是有些冗余。下面介绍一种更简洁的思路，该方法是一个一般化版本，即对于at most k的版本也适用。注意到我们一直没有利用到已覆盖的那部分新数组的信息，可以利用该信息做一些额外的判断和简化。

* 如果n <= k，则可以直接返回 n。因为就算数组元素全部相等，数量也 <= k个。
* 同样维护两个指针 i 和 j，功能同上。
* 当n > k时，前k项可以不管，直接从下标为k处遍历，即 i = k，j = k。
  * 如果**nums[i] == nums[j - k]**，由于有序性，我们知道从j - k 到 j - 1的位置都相等，如果这时再覆盖的话，就会超过k次的限制。所以不能覆盖。
  * 否则，就覆盖位置 j 并更新 j。
  * 更新下标 i 。
* 最后返回 j。



