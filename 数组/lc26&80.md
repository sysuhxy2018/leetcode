### 代码

``` java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int i = 0, j = 0;
        while (i < n) {
            int cnt = 0;
            while (i + 1 < n && nums[i + 1] == nums[i]) {
                if (cnt < 2) {
                    nums[j] = nums[i];
                    j++;
                    cnt++;
                }
                i++;
            }
            if (cnt < 2) {
                nums[j] = nums[i];
                j++;
                cnt++;
            }
            i++;  
        }
        return j;
    }
}
```



### 思路

这两题比较类似，就放到一起说了。先简单说一下我自己的写法。

* 维护两个指针，i 为遍历指针，j为覆盖指针（表示当前可被覆盖的下标位置）。都初始化为0。
* while i 不越界
  * 设置cnt = 0用于计数。
  * while 遍历一直到最后一个不重复的数
    * 其中如果cnt < 2，就更新nums[j]。然后cnt 和 j 都更新。
    * 遍历下标 i 更新。
  * 经过上面的while，i 已经到最后一个不重复的数了
    * 其中如果cnt < 2，就更新nums[j]。然后cnt 和 j 都更新。
    * 遍历下标 i 更新。
* 最后 j 就表示已经覆盖的元素数量，即新数组的长度，返回 j 即可。

