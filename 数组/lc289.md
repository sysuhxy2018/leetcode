### 代码

``` java
import java.util.*;

class Solution {
    private int m, n;
    
    public void gameOfLife(int[][] board) {
        m = board.length;
        if (m == 0)
            return;
        n = board[0].length;
        if (n == 0)
            return;
        
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++) {
                int a = count(board, i, j);
                if (board[i][j] == 1) {
                    if (a < 2 || a > 3)
                        board[i][j] = 2;
                }
                else{
                    if (a == 3)
                        board[i][j] = 3;
                }
            }
        
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                board[i][j] %= 2;
    }
    
    private int count(int[][] board, int y, int x) {
        int live = 0;
        for (int i = y - 1; i <= y + 1; i++)
            for (int j = x - 1; j <= x + 1; j++)
                if (!(i == y && j == x) && valid(i, j)) {
                    if (board[i][j] == 1 || board[i][j] == 2)
                        live++;
                }
        return live;
    }
    
    private boolean valid(int y, int x) {
        return y >= 0 && y < m && x >= 0 && x < n;
    }
}
```



### 思路

此题模拟的是一个简单的生命游戏。首先介绍一下游戏设定和规则：

* 初始给定一个m x n的矩阵，每个格子表示一个细胞，状态是生（1）或者死（0）。
* 每个细胞根据它周围的格子（一般是8个，但边界处可能少于8个）进行演化，规则如下：
  * 如果这个细胞是活的，则它周围只能有2个或者3个活细胞，否则这个细胞死掉。
  * 如果这个细胞是死的，则当且仅当它周围有3个活细胞时，这个细胞复活。
* 每个细胞的演化都是同时发生的，这意味着我们不能直接在原矩阵操作。因为新的值会覆盖掉旧的值，并且后续的运算会根据新值来推断，这不是我们想要的结果。

P.S. 这里我们模拟的只是一轮演化，且固定死了边界。而在原版的游戏中矩阵的边界是可以不断扩张的，可以一直演化直到所有细胞都死掉。

如果我们新建一个同样大小的矩阵，把每个细胞演化的结果存进去，然后再覆盖回原矩阵，这样做是非常简单的，但是空间复杂度是O(m * n)。这题的难点在于如何降低空间复杂度，下面介绍一种最优的方法，只需O(1)的空间复杂度。

其实我们可以直接在原矩阵操作，前提覆盖后的**新值可以还原回旧值**。这点类似于有限状态机，所以我们可以在原有的两个状态基础上扩充为四个状态：

* 编码 0：死 -> 死
* 编码 1：生 -> 生
* 编码 2：生 -> 死
* 编码 3：死 -> 生

这样一来，我们可以不用理会到底是新值还是旧值。因为无论是哪种编码，无论是新值还是旧值（旧值只有0和1），都可以知道细胞原来是生还是死。

最后遍历更新完矩阵后，还要转回原来的0 - 1两种状态。比较简单的转换方式是直接模2，余数为0的恰好对应死（0），余数为1的恰好对应生（1）。就不需要switch或者if - else结构判断了。

详细的伪码这里就不写了，主要注意以下几个问题：

* 特殊情况的处理，m = 0 或者 n = 0都无效。

* 只统计周围的细胞，不包括自身在内，且要检查位置是否越界。

* 仔细阅读演化规则会发现，只需统计周围活细胞的数量即可，不用管死细胞。原来是活细胞的编码只有1 和 2。



### 总结

这题不像前面的remove in-place类型的题目，可以拿出一部分来存储额外的信息。所以为了兼顾更新前和更新后的状态，设计了新的状态编码，从而可以直接在原矩阵中replace。

此外，编码的方式兼顾了旧值。因为旧值只有0和1，所以我们在设计时将新值保持不变的情况也分别设计为了0和1。