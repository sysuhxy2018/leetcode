### 代码

``` java
// 时间复杂度O(n^2)
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        for (int i = 0; i < n; i++) {
            int sum = 0, j = i;
            boolean flag = true;
            while ((j + 1) % n != i) {
                sum += gas[j];
                if (sum < cost[j]) {
                    flag = false;
                    break;
                }
                sum -= cost[j];
                j = (j + 1) % n;
            }
            sum += gas[j];
            if (sum < cost[j])
                flag = false;
            if (flag)
                return i;
        }
        return -1;
    }
}

// 时间复杂度O(n)
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int ans = 0, sum = 0, total = 0;
        for (int i = 0; i < n; i++) {
            sum += gas[i] - cost[i];
            total += gas[i] - cost[i];
            if (sum < 0) {
                ans = (i + 1) % n;
                sum = 0;
            }
        }
        return total >= 0 ? ans : -1;
    }
}
```



### 思路

首先最直接的一种方法是从每个加油站开始做一次循环遍历，看是否能够回到起点。时间复杂度为O(n^2)，并不是一种理想的方法，但还是简要说明一下循环遍历的整个过程：

* 除了起点位置 i 外，还需要维护几个其他变量
  * 遍历指针 j，初值设为 i 。
  * 油箱里油的数量sum，初值设为0。
  * 布尔值flag，用于标记是否能够成功完成遍历，初值为true。
* 循环终止的条件
  * 由于我们是从 i 开始最后回到 i，所以应该写成while (j != i)，即 j == i 时跳出。但是由于 j 的初值已经设为 i 了，这样一来就不会进入这个循环。我们可以退一步，即先到 i 前面那个点。循环终止条件就变成了 j + 1 == i。又因为这是一个循环遍历，所以保证下标始终 < n，需要做模运算，即应该为 (j + 1) % n == i跳出。所以最终while条件应该写成 **(j + 1) % n != i**。
* 循环内容
  * 每到达一个加油站，第一件事就是加油。所以sum += gas[j]。
  * 然后我们要从点 j 移动到下一个点，需要耗油cost[j]。
    * 如果sum < cost[j]，说明油量不够，直接设置flag为false，跳出循环。
    * 如果sum >= cost[j]，足够，sum更新，要减去cost[j]。
  * 到达下一个加油站，j 也要同时更新，j 加 1 后 取模。j = (j + 1) % n。
* while终止后我们只到达了 i 前面的加油站 j，还需多做一步操作，看 j 能不能最终到达 i。按循环里面的内容重复同样的操作即可。
* 最后根据flag来判断从起点位置 i 能否完成循环遍历。true则直接返回（题目保证不会出现多组解）；否则继续从下一个起点位置遍历。

然后这里再介绍一种最优解，只需O(n)的时间复杂度。

* 维护3个额外变量
  * total，表示的是整个遍历过程中所能累积的最终油量（可以为负数）。
  * sum，表示的是整个遍历过程中某个起点位置所能够累积的油量（一直到遍历结束为止就停止了，不能为负数）
  * j，表示的是某个候选的起点位置，可能完成循环遍历。
* 简单从0 ~ n - 1遍历一次，不是循环遍历
  * 加油再耗油。即sum += gas[i] - cost[i]，同时total += gas[i] - cost[i]。
  * 由于sum不能为负，如果sum < 0，说明如果从 j 开始，中途会遇到无法从 i 到 i  + 1的情况，所以要更新 j。直接更新为 i + 1即可。为了防止越界，做一个模n运算。此外，还要记得重置sum为0。
* 遍历完毕后，检查total是否 >= 0，如果是，说明必定存在这样一个起始位置；否则，不存在，返回 -1。如果存在，这个位置就是最后的候选位置 j ，返回 j。

至于这种算法的原理，目前还搞不太清楚，似乎是运用了贪心的思想。唯一确定的是，可以根据total来确定是否有解。因为不管从哪个起点开始，循环遍历一圈相当于total = sum(gas(i)) - sum(cost(i))。即这个结果都是一样的。如果total < 0，说明总油耗 > 总油量，肯定不能完成循环遍历；反之，则必然存在解。至于这个解为什么是ans就不得而知了。



### 总结

有关数组的循环遍历，前面已经说得很清楚了，这里就不再花时间总结模板了。无非就是注意几点：

* 遍历的终止是在起点的前一个位置。完了之后还要再多移动一个位置回到起点。
* 任何涉及下标的运算都要模n。

另外，关于一些布尔变量的初始化问题，这里可以记录一些心得体会。

在做题的时候会发现，有的时候布尔变量初始化为false，有的时候为true。这样做的原因一方面和这个布尔值所要表达的意思相关，另一方面则是和运算的整个过程相关。这个问题本质上是一个与（&&）还是或（||）的问题。

假设我们最终都想要得到布尔值为true的结果。如果运算中出现了多种情况，必须都满足这些情况，如果有一个情况不满足，则直接设置为false，那么这就是一个与运算，初值应该设置为true。如果运算中出现了多种情况，只要满足至少一种就可以，如果有一个情况满足，则直接设置为true，那么这就是一个或运算，初值应该设置为false。