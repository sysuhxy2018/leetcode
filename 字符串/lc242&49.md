### 代码

``` java
// Valid Anagram
class Solution {
    public boolean isAnagram(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        if (ss.length != tt.length)
            return false;
        
        int[] letters = new int[26];
        for (char c : ss)
            letters[c - 'a']++;
        for (char c : tt)
            letters[c - 'a']--;
        for (int i = 0; i < 26; i++)
            if (letters[i] != 0)
                return false;
        return true;
    }
}
```



### 思路

题目的意思是判断字符串 t 是否是字符串 s 的一个重组，即 t 是否使用了和 s 相同的小写字母（种类和数量）。由于这里字符串默认都是小写字母，所以我们可以不需要用HashMap结构，可以直接用一个26大小的数组来作为哈希表。

* 首先判断 s 和 t 的长度是否相等，如果不等，那肯定无法形成重组，直接返回 false。
* 然后维护一个字母次数统计数组 letters，大小为26。
* 遍历字符串s的每个字符，将letters中对应的字母项加1
* 接着遍历字符串t的每个字符，将letters中对应的字母项减1
* 如果t是s的重组的话，最后letters的**每一项应该都是0**，只要有一项不是0，则直接返回false。最后都是0的话，返回true即可。



### 总结

这里原题还有一个拓展，就是如果字符没有限制为小写字母，而是Unicode字符应该怎么做。这里的话，考虑到Java里面的char最多只有16位，即最多只能表示65536个不同的字符。所以其实还是可以用一个65536大小的数组来作为哈希表。但一般情况下，字符串不可能包含所有这些字符，会有很多重复的，所以用HashMap会更节省空间一些。下面是HashMap的代码，可以看到基本上和上面代码的写法类似：

``` java
class Solution {
    public boolean isAnagram(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        if (ss.length != tt.length)
            return false;
        HashMap<Character, Integer> hm = new HashMap<>();
        for (char c : ss) {
            if (hm.containsKey(c))
                hm.put(c, hm.get(c) + 1);
            else
                hm.put(c, 1);
        }
        for (char c : tt) {
            if (hm.containsKey(c))
                hm.put(c, hm.get(c) - 1);
            else
                return false;
        }
        for (Map.Entry<Character, Integer> entry : hm.entrySet()) {
            if (entry.getValue() != 0)
                return false;
        }
        return true;
    }
}
```



<hr>

### 代码

``` java
// Group Anagrams
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();
        HashMap<String, ArrayList<String>> group = new HashMap<>();
        for (String str : strs) {
            char[] tmp = str.toCharArray();
            Arrays.sort(tmp);
            String ana = new String(tmp);
            if (group.containsKey(ana))
                group.get(ana).add(str);
            else {
                ArrayList<String> item = new ArrayList<>();
                item.add(str);
                group.put(ana, item);
            }
        }
        for (Map.Entry<String, ArrayList<String>> entry : group.entrySet())
            ans.add(entry.getValue());
        return ans;
    }
}
```



### 思路

这里题目是给定一个字符串数组，然后要你将它们分类。属于同一个重组的就分成一组，最后返回不同的分组。这里我们需要用到一个新的概念，即将两个字符串**按照字典顺序排序**后，如果它们**相等**，则说明它们属于同一分组。这是非常直观且容易理解的，不过要注意我们要先将字符串转成char数组然后才能对数组排序。

* 维护一个结果列表ans，ans用于存储分组。
* 维护一个HashMap，键为String，**值为ArrayList\<String\>**。键表示的是用于标记不同分组的唯一字符串，值表示的是当前所能构成的不同的分组。
* 遍历字符串数组strs
  * 首先对每一项字符转成char数组。
  * 调用Arrays.sort方法排序。
  * 得到一个新的字符串ana。
  * 如果HashMap已经存在ana表示的分组了，那么直接add新的字符串str。
  * 如果不存在，则需要新建一个分组，然后add新的字符串str。最后将ana和新分组组成的键值对put到HashMap中。
* 此时HashMap里面存放的就是所有的分组，那么只需遍历然后添加分组到ans里面即可。
* 最后返回ans。

我们来分析一下复杂度，首先是时间，为O(NKlogK)。时间主要集中在遍历和处理strs上，其中N为字符串数组大小，K为字符串数组里最长字符串的长度。因为有N个字符串要处理，每次要排序花费O(KlogK)时间，所以最终就是O(NKlogK)。

而空间的话，主要就是存储分组，所以是O(NK)，即相当于有多少个字符。

实际上我们还可以再优化一下时间复杂度。考虑到所有字符都是小写字母，所以我们可以统计每个字母出现的次数，然后自己创造一个编码来标记不同的分组。这里编码的方式是 '#' + 数目1  + '#' + 数目2 + ... ，如下图所示：

<img src="https://leetcode.com/problems/group-anagrams/Figures/49_groupanagrams2.png" alt="lc49" style="zoom: 75%;" />

代码如下，详细的思路就不说了，基本和上面的一样，只是HashMap里键的表示方式不一样。

``` java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, ArrayList<String>> group = new HashMap<>();
        int[] letters = new int[26];
        for (String str : strs) {
            Arrays.fill(letters, 0);
            char[] cs = str.toCharArray();
            StringBuilder sb = new StringBuilder();
            for (char c : cs)
                letters[c - 'a']++;
            for (int letter : letters) {
                sb.append("#");
                sb.append(letter);
            }
            String ana = sb.toString();
            if (!group.containsKey(ana))
                group.put(ana, new ArrayList<String>());
            group.get(ana).add(str);
        }
        return new ArrayList<List<String>>(group.values());
    }
}
```

然后是一些注意事项：





### 总结









