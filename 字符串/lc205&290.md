### 代码

``` java
// Isomorphic Strings
// 哈希表1
class Solution {
    public boolean isIsomorphic(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        
        HashMap<Character, Character> m1 = new HashMap<>();
        HashMap<Character, Character> m2 = new HashMap<>();
        
        for (int i = 0; i < ss.length; i++) {
            if (m1.containsKey(ss[i])) {
                if (m1.get(ss[i]) != tt[i])
                    return false;
            }
            else
                m1.put(ss[i], tt[i]);
            if (m2.containsKey(tt[i])) {
                if (m2.get(tt[i]) != ss[i])
                    return false;
            }
            else
                m2.put(tt[i], ss[i]);
        }
        
        return true;
    }
}

// 哈希表2
class Solution {
    public boolean isIsomorphic(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        
        char[] m1 = new char[128];
        char[] m2 = new char[128];
        
        for (int i = 0; i < ss.length; i++) {
            if (m1[ss[i]] != '\0') {
                if (m1[ss[i]] != tt[i])
                    return false;
            }
            else
                m1[ss[i]] = tt[i];
            if (m2[tt[i]] != '\0') {
                if (m2[tt[i]] != ss[i])
                    return false;
            }
            else
                m2[tt[i]] = ss[i];
        }
        
        return true;
    }
}
```



### 思路

首先题目意思是让我们建立一个 s 中字符和 t 中字符的**双向映射**，也就是一一对应。但是只有一个哈希表的话，可能会出现多对一的情况。所以需要我们再逆向用哈希表建立逆映射。即总共需要**两张哈希表**。

由于题目默认 s 和 t 的长度是相等的，所以我们不需要再比较了。如果长度不等的话，直接就返回false了。另外，关于 s 和 t 都是空串的特殊情况，我们的代码返回的结果是 true，是正确的，所以不用再额外考虑。

* 遍历 s 串
  * 检查 ss[i] 和 tt[i] 之间的**映射关系**
    * 检查是否存在 ss[i] 到 tt[i] 的有效映射。如果不存在，则添加；如果存在，检查从ss[i]得到的值是不是tt[i]，不是的话就返回false。
    * 检查是否存在 tt[i] 到 ss[i] 的有效映射。方法同上。
* 如果中途没有返回 false，说明 s 和 t 之间存在有效的双向映射。返回true即可。

此外，这里有一个性能上的小优化。因为单纯用HashMap的话，不知道为什么跑出来的结果很慢。所以还是换成固定长度的哈希数组好了。因为刷题的时候一般只会用到128个ASCII码（对应的是0 ~ 127的int值），所以直接开一个128大小的数组就可以了（有些人会为了保险起见开成256的，其实没所谓）。char数组的话会默认初始化为 int 值为0的char字符，即**'\0'（空字符）**，所以我们判断这个映射是否存在就看它是不是等于 '\0' 就行了，当然也可以直接和数值 0 比较。



<hr>

### 代码

``` java
// Word Pattern

```



