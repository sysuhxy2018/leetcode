### 代码

``` java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        if (n == 0)
            return 0;
        
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++)
            dp[i][i] = 1;
        
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j))
                    dp[i][j] = 2 + dp[i + 1][j - 1];
                else
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                
            }
        }
        
        return dp[0][n - 1];
    }
}
```



### 思路

dp。时间复杂度为O(n ^ 2)。

* dp的变量。这里dp的量是一个n x n的二维矩阵。其中 dp\[i\]\[j\] 表示下标 i 到 下标 j 的子串所能包含的最长对称子序列的长度。
  * 初始化，考虑一个字符的子串，即i == j的情况。这时最长对称子序列就是这个字符本身，长度为1。这种**对角线形式**的初始化也是这类dp变量最常见的初始化方式。
* 状态转移方程
  * 考虑dp(i, j) (j > i)的情况。
  * 如果位置 i 和位置 j 的字符相等，则dp(i, j) = dp(i + 1, j - 1) + 2。
  * 如果不等，则dp(i, j) = max{ dp(i + 1, j), dp(i, j - 1) }。即我们需要考虑保留一端而丢弃另一端的情况。有人会问，应该还有一种情况是两端都丢弃的情况，即dp(i + 1, j - 1)。但是这种情况本身就是多余的，因为它都包含在前面这两种情况里面。dp考虑情况时，原则是所有情况都要独立，不能出现包含与被包含的情况。
  * 得到状态转移方程后，我们可以顺带得出迭代更新的方式。由于是二维矩阵，所以肯定嵌套两个for循环。然后 i 从大到小更新； j 从小到大更新，并且 j 的起始位置是 i + 1。
* 最后的结果。
  * 根据dp变量的定义，最后的结果就是dp(0, n - 1)，即整个字符串所能包含的最长对称子序列的长度。

最后注意一下特殊情况的考虑。这里特殊情况是空字符串，即n == 0的时候，如果不单独考虑，最后dp(0, n - 1)会出问题。空串直接返回0。