### 代码

``` java
// path sum
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null)
            return false;
        sum -= root.val;
        if (root.left == null && root.right == null && sum == 0)
            return true;
        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
    }
}

// path sum 2
class Solution {
    private List<List<Integer>> ans = new ArrayList<>();
    
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        findPath(root, sum, new ArrayList<Integer>());
        return ans;
    }
    
    private void findPath(TreeNode root, int sum, List<Integer> tmp) {
        if (root == null)
            return;
        tmp.add(root.val);
        sum -= root.val;
        if (root.left == null && root.right == null && sum == 0)
            ans.add(new ArrayList<Integer>(tmp));
        findPath(root.left, sum, tmp);
        findPath(root.right, sum, tmp);
        tmp.remove(tmp.size() - 1);
    }
}

// path sum 3
class Solution {
    
    public int pathSum(TreeNode root, int sum) {
        if (root == null)
            return 0;
        return rootSum(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }
    
    public int rootSum(TreeNode root, int sum) {
        if (root == null)
            return 0;
        sum -= root.val;
        int base = 0;
        if (sum == 0)
            base = 1;
        return rootSum(root.left, sum) + rootSum(root.right, sum) + base;
    }
}
```

### 思路

path sum和path sum 2比较像，可以用同一套模板：

* 检查是否null
* 非null，更新sum和list
* 找到path条件：**叶子 && sum == 0**；找不到，继续递归左右子树
* 如果回溯，返回前还原list (sum是局部变量，按值传递，不还原)

path sum 2维护一个全局的list来记录路径，需要回溯。

path sum 3是新题，路径无需从根开始，也无需到叶子结束。

