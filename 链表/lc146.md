### 代码

``` java
import java.util.*;
class LRUCache {

    private HashMap<Integer, Integer> data;
    private Queue<Integer> cache;
    private int capacity;
    
    public LRUCache(int capacity) {
        data = new HashMap<>();
        cache = new LinkedList<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if (data.containsKey(key)) {
            cache.remove(Integer.valueOf(key));
            cache.offer(key);
            return data.get(key);
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if (!data.containsKey(key)) {
            if (data.size() == capacity)
                data.remove(cache.poll());
            data.put(key, value);
            cache.offer(key);
        }
        else {
            data.put(key, value);
            cache.remove(Integer.valueOf(key));
            cache.offer(key);
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



### 思路

首先我们不考虑复杂度，先把逻辑理一理。

* 数据域
  * HashMap<Integer, Integer>，用于存键值对数据。
  * Queue\<Integer\>，用于维护一个key的序列，按时间（操作）先后顺序排列。
  * capacity，用于设置cache的大小。同时也限制了HashMap和Queue的大小。
* 方法
  * 构造方法，比较简单，用于初始化。
    * 设置capacity
    * 用new操作符给HashMap和Queue分配内存空间
  * get方法，根据key返回对应的value。
    * 检查HashMap里面是否有给定key的键，如果没有，直接返回-1。
    * 如果有，则视为一次成功used。此时cache里面必定也会有对应key的元素存在，我们要做的就是找出该元素，并把它放到队列末尾，因为它现在是最新的used key。所以cache先remove然后再offer插入。完成操作后，还要返回key对应的value。
  * put方法，插入键值对。
    * 如果HashMap里面没有给定key的键，说明这是一个新键，HashMap和cache里面都没有。
      * 检查HashMap的大小，如果满了（== capacity)，则必须要remove掉least used那个。即弹出队列里的队首元素，然后remove掉以队首元素为键的键值对。
      * 然后就有有空位插入了，直接put键值对，同时记得将新的key值入列。因为这也算一次成功的used。
    * 如果key值重复，则我们需要：
      * 继续往HashMap里put一次，相当于覆盖value。
      * 和get里的情况类似，也算一次成功的used，cache先remove然后offer插入。

总结起来就是：**get只有有才算used，put怎样都算used**。

然后是效率上的优化，这里最拖后腿的是队列的remove操作。时间复杂度的话应该是O(n)级别的，其实就是简单的线性查找然后删除。为了将效率提升至O(1)，我们可以用一个双向链表的结构代替原来的队列，此外建立一个key和Node之间的映射，这样可以直接根据key定位到需要remove的结点。其实Java里的LinkedList本身就是双向链表，但是因为封装得太好，无法让我们自由地操作结点，改变指向等等，所以我们需要自己实现一个双向链表。此外，可以直接在Node结点里同时存储key和value，这样就不需要额外再用一个HashMap来记录data了。

代码如下：

``` java
class LRUCache {

    private int capacity;
    private HashMap<Integer, Node> index;
    private Node head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        index = new HashMap<>();
    }
    
    public int get(int key) {
        if (index.containsKey(key)) {
            int value = index.get(key).value;
            deleteNode(index.get(key));
            index.put(key, addNode(key, value));
            return value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if (index.containsKey(key)) {
            deleteNode(index.get(key));
            index.put(key, addNode(key, value));
        }
        else {
            if (index.size() >= capacity) {
                index.remove(deleteHead());
            }
            index.put(key, addNode(key, value));
        }
    }
    
    private Node addNode(int key, int value) {
        Node tmp = new Node(key, value);
        index.put(key, tmp);
        if (head == null) {
            head = tail = tmp;
        }
        else {
            tail.next = tmp;
            tmp.prev = tail;
            tail = tmp;
        }
        return tmp;
    }
    
    private void deleteNode(Node dNode) {
        Node prev = null, next = null;
        prev = dNode.prev;
        next = dNode.next;
        if (prev != null)
            prev.next = next;
        else
            head = next;
        if (next != null)
            next.prev = prev;
        else
            tail = prev;
    }
    
    private int deleteHead() {
        int key = head.key;
        deleteNode(head);
        return key;
    }
}

class Node {
    int key, value;
    Node prev, next;
    Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

先来说一下双向链表的三个方法。我个人是不推荐这三个方法里又操作其他数据结构如HashMap的，会比较乱。这三个方法只针对链表的操作。

* 