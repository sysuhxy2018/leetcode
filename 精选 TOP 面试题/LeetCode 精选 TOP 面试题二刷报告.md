# LeetCode 精选 TOP 面试题二刷报告



### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

* 参考[链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)的解法三。个人感觉解法三相比解法四要更清晰易懂些。
* 首先将问题转化成求两个数组中第K个数的问题，这里K取(m + n + 1) / 2和(m + n + 2) / 2，刚好就是中间两个数。
* 对于上面的问题，用递归解决。
  * 首先让长度上数组A <= 数组B（如果不是，将**参数的位置换一下**，再调用一次方法即可，），则如果**A为空**，剩下就可以直接从B里找第K个。
  * 另外，如果**K == 1**，则可以直接比较数组A和数组B的第一个元素，取**较小**的那个。
  * 对于一般情况，取A和B的**第K / 2个**元素来比较（如果没有，就取到**最末尾**那个元素，可以用Math.min(K / 2, len）来获取长度）。**小的**那一方，就能排除掉数组的**前半部分（包括刚才比较的元素）**。根据排除掉的数量，更新K和小的那一方数组的范围即可。

### [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

* 首先不判断溢出的情况下，代码是不难写的。注意while的条件不再是x > 0而是**x != 0**，因为可能涉及到负数。
* 溢出判断要加在每次**更新sum前**。注意这里sum和d都是**带符号的**，所以判断的时候直接分**正负溢出**判断即可。

### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

* 比较粗暴的方法是直接细分成13个单元到哈希表里，然后匹配（先匹配两个字符的）。
* 但其实仍然可以只处理7个单元，比较当前和下一位的数字，如果**当前更小**，说明它和下一位是连体的。那么，其实可以将它用**负数表示**。其余情况就按正数表示累加。